diff --git a/src/api/api_solver.cpp b/src/api/api_solver.cpp
index f226529de..94140d200 100644
--- a/src/api/api_solver.cpp
+++ b/src/api/api_solver.cpp
@@ -16,7 +16,7 @@ Author:
 Revision History:
 
 --*/
-#include<thread>
+//#include<thread>
 #include "util/scoped_ctrl_c.h"
 #include "util/cancel_eh.h"
 #include "util/file_path.h"
@@ -162,17 +162,17 @@ extern "C" {
 
 
     static void init_solver_log(Z3_context c, Z3_solver s) {
-        static std::thread::id g_thread_id = std::this_thread::get_id();
-        static bool g_is_threaded = false;
+        //static std::thread::id g_thread_id = std::this_thread::get_id();
+        //static bool g_is_threaded = false;
         solver_params sp(to_solver(s)->m_params);
         symbol smt2log = sp.smtlib2_log();
         if (smt2log.is_non_empty_string() && !to_solver(s)->m_pp) {
-            if (g_is_threaded || g_thread_id != std::this_thread::get_id()) {
-                g_is_threaded = true;
-                std::ostringstream strm;
-                strm << smt2log << '-' << std::this_thread::get_id();
-                smt2log = symbol(std::move(strm).str());
-            }
+            //if (g_is_threaded || g_thread_id != std::this_thread::get_id()) {
+            //    g_is_threaded = true;
+            //    std::ostringstream strm;
+            //    strm << smt2log << '-' << std::this_thread::get_id();
+            //    smt2log = symbol(std::move(strm).str());
+            //}
             to_solver(s)->m_pp = alloc(solver2smt2_pp, mk_c(c)->m(), smt2log.str());
         }
     }
diff --git a/src/api/js/scripts/build-wasm.ts b/src/api/js/scripts/build-wasm.ts
index 497b67c10..881acaad1 100644
--- a/src/api/js/scripts/build-wasm.ts
+++ b/src/api/js/scripts/build-wasm.ts
@@ -15,8 +15,8 @@ const SWAP_OPTS: SpawnOptions = {
   stdio: 'inherit',
   env: {
     ...process.env,
-    CXXFLAGS: '-pthread -s USE_PTHREADS=1 -s DISABLE_EXCEPTION_CATCHING=0',
-    LDFLAGS: '-s WASM_BIGINT -s -pthread -s USE_PTHREADS=1',
+    CXXFLAGS: '-s DISABLE_EXCEPTION_CATCHING=0',
+    LDFLAGS: '-s WASM_BIGINT',
     FPMATH_ENABLED: 'False', // Until Safari supports WASM SSE, we have to disable fast FP support
     // TODO(ritave): Setting EM_CACHE breaks compiling on M1 MacBook
     //EM_CACHE: path.join(os.homedir(), '.emscripten/'),
@@ -40,7 +40,7 @@ function spawnSync(command: string, opts: SpawnOptions = {}) {
 }
 
 function exportedFuncs(): string[] {
-  const extras = ['_malloc', '_set_throwy_error_handler', '_set_noop_error_handler', ...asyncFuncs.map(f => '_async_' + f)];
+  const extras = ['_malloc', '_free', '_set_throwy_error_handler', '_set_noop_error_handler', ...asyncFuncs.map(f => '_async_' + f)];
 
   // TODO(ritave): This variable is unused in original script, find out if it's important
   const fns: any[] = (functions as any[]).filter(f => !asyncFuncs.includes(f.name));
@@ -69,7 +69,7 @@ const fns = JSON.stringify(exportedFuncs());
 const methods = '["ccall","FS","allocate","UTF8ToString","intArrayFromString","ALLOC_NORMAL"]';
 const libz3a = path.normalize('../../../build/libz3.a');
 spawnSync(
-  `emcc build/async-fns.cc ${libz3a} --std=c++20 --pre-js src/low-level/async-wrapper.js -g2 -pthread -fexceptions -s WASM_BIGINT -s USE_PTHREADS=1 -s PTHREAD_POOL_SIZE=0 -s PTHREAD_POOL_SIZE_STRICT=0 -s MODULARIZE=1 -s 'EXPORT_NAME="initZ3"' -s EXPORTED_RUNTIME_METHODS=${methods} -s EXPORTED_FUNCTIONS=${fns} -s DISABLE_EXCEPTION_CATCHING=0 -s SAFE_HEAP=0 -s DEMANGLE_SUPPORT=1 -s TOTAL_MEMORY=2GB -s TOTAL_STACK=20MB -I z3/src/api/ -o build/z3-built.js`,
+  `emcc build/async-fns.cc ${libz3a} --std=c++20 --pre-js src/low-level/async-wrapper.js -g2 -fexceptions -s WASM_BIGINT -s MODULARIZE=1 -s 'EXPORT_NAME="initZ3"' -s EXPORTED_RUNTIME_METHODS=${methods} -s EXPORTED_FUNCTIONS=${fns} -s DISABLE_EXCEPTION_CATCHING=0 -s SAFE_HEAP=0 -s DEMANGLE_SUPPORT=1 -s TOTAL_MEMORY=2GB -s TOTAL_STACK=20MB -I z3/src/api/ -o build/z3-built.js`,
 );
 
 fs.rmSync(ccWrapperPath);
diff --git a/src/api/js/scripts/make-cc-wrapper.ts b/src/api/js/scripts/make-cc-wrapper.ts
index 2b7ca2536..4ac538e37 100644
--- a/src/api/js/scripts/make-cc-wrapper.ts
+++ b/src/api/js/scripts/make-cc-wrapper.ts
@@ -35,7 +35,7 @@ extern "C" void async_${fn.name}(${fn.params
   return `// THIS FILE IS AUTOMATICALLY GENERATED BY ${path.basename(__filename)}
 // DO NOT EDIT IT BY HAND
 
-#include <thread>
+#include <string>
 
 #include <emscripten.h>
 
@@ -43,71 +43,26 @@ extern "C" void async_${fn.name}(${fn.params
 
 template<typename Fn, Fn fn, typename... Args>
 void wrapper(Args&&... args) {
-  std::thread t([...args = std::forward<Args>(args)] {
-    try {
-      auto result = fn(args...);
-      MAIN_THREAD_ASYNC_EM_ASM({
-        resolve_async($0);
-      }, result);
-    } catch (std::exception& e) {
-      MAIN_THREAD_ASYNC_EM_ASM({
-        reject_async(new Error(UTF8ToString($0)));
-      }, e.what());
-    } catch (...) {
-      MAIN_THREAD_ASYNC_EM_ASM({
-        reject_async('failed with unknown exception');
-      });
-    }
-  });
-  t.detach();
+  auto result = fn(std::forward<Args>(args)...);
+  MAIN_THREAD_ASYNC_EM_ASM({
+    resolve_async($0);
+  }, result);
 }
 
 template<typename Fn, Fn fn, typename... Args>
 void wrapper_str(Args&&... args) {
-  std::thread t([...args = std::forward<Args>(args)] {
-    try {
-      auto result = fn(args...);
-      MAIN_THREAD_ASYNC_EM_ASM({
-        resolve_async(UTF8ToString($0));
-      }, result);
-    } catch (std::exception& e) {
-      MAIN_THREAD_ASYNC_EM_ASM({
-        reject_async(new Error(UTF8ToString($0)));
-      }, e.what());
-    } catch (...) {
-      MAIN_THREAD_ASYNC_EM_ASM({
-        reject_async(new Error('failed with unknown exception'));
-      });
-    }
-  });
-  t.detach();
-}
-
-
-
-class Z3Exception : public std::exception {
-public:
-  const std::string m_msg;
-  Z3Exception(const std::string& msg) : m_msg(msg) {}
-  virtual const char* what() const throw () {
-    return m_msg.c_str();
-  }
-};
-
-void throwy_error_handler(Z3_context ctx, Z3_error_code c) {
-  throw Z3Exception(Z3_get_error_msg(ctx, c));
-}
-
-void noop_error_handler(Z3_context ctx, Z3_error_code c) {
-  // pass
+  auto result = fn(std::forward<Args>(args)...);
+  MAIN_THREAD_ASYNC_EM_ASM({
+    resolve_async(UTF8ToString($0));
+  }, result);
 }
 
 extern "C" void set_throwy_error_handler(Z3_context ctx) {
-  Z3_set_error_handler(ctx, throwy_error_handler);
+  // no-op
 }
 
 extern "C" void set_noop_error_handler(Z3_context ctx) {
-  Z3_set_error_handler(ctx, noop_error_handler);
+  // no-op
 }
 
 ${wrappers.join('\n\n')}
diff --git a/src/test/scoped_timer.cpp b/src/test/scoped_timer.cpp
index 742ea2652..2bdbb966c 100644
--- a/src/test/scoped_timer.cpp
+++ b/src/test/scoped_timer.cpp
@@ -3,6 +3,7 @@
 // with single and multi-threaded mode and short timeouts.
 // run it with app-verifier (becuzz yes ...)
 
+#if 0
 #include "util/scoped_timer.h"
 #include "util/util.h"
 #include "util/vector.h"
@@ -51,3 +52,4 @@ void tst_scoped_timer() {
         th.join();
     
 }
+#endif
diff --git a/src/util/memory_manager.cpp b/src/util/memory_manager.cpp
index 8c6bfc7e7..362de6716 100644
--- a/src/util/memory_manager.cpp
+++ b/src/util/memory_manager.cpp
@@ -160,7 +160,7 @@ void memory::finalize(bool shutdown) {
         g_finalizing = false;
 
         if (shutdown) {
-            scoped_timer::finalize();
+            // scoped_timer::finalize();
         }
     }
 }
diff --git a/src/util/scoped_timer.cpp b/src/util/scoped_timer.cpp
index ce1b14a23..98ca8f0dc 100644
--- a/src/util/scoped_timer.cpp
+++ b/src/util/scoped_timer.cpp
@@ -20,131 +20,12 @@ Revision History:
 --*/
 
 #include "util/scoped_timer.h"
-#include "util/mutex.h"
-#include "util/util.h"
-#include <atomic>
-#include <chrono>
-#include <climits>
-#include <condition_variable>
-#include <mutex>
-#include <thread>
-#include <vector>
-#ifndef _WINDOWS
-#include <pthread.h>
-#endif
-
-enum scoped_timer_work_state { IDLE = 0, WORKING = 1, EXITING = 2 };
-
-struct scoped_timer_state {
-    std::thread m_thread;
-    std::timed_mutex m_mutex;
-    event_handler * eh;
-    unsigned ms;
-    std::atomic<scoped_timer_work_state> work;
-    std::condition_variable_any cv;
-};
-
-static std::vector<scoped_timer_state*> available_workers;
-static std::mutex workers;
-static atomic<unsigned> num_workers(0);
-
-static void thread_func(scoped_timer_state *s) {
-    workers.lock();
-    while (true) {
-        s->cv.wait(workers, [=]{ return s->work != IDLE; });
-        workers.unlock();
-
-        if (s->work == EXITING)
-            return;
-
-        auto end = std::chrono::steady_clock::now() + std::chrono::milliseconds(s->ms);
-
-        while (!s->m_mutex.try_lock_until(end)) {
-            if (std::chrono::steady_clock::now() >= end) {
-                s->eh->operator()(TIMEOUT_EH_CALLER);
-                goto next;
-            }
-        }
-
-        s->m_mutex.unlock();
-
-    next:
-        s->work = IDLE;
-        workers.lock();
-    }
-}
-
 
 scoped_timer::scoped_timer(unsigned ms, event_handler * eh) {
-    if (ms == 0 || ms == UINT_MAX)
-        return;
-
-    workers.lock();
-    if (available_workers.empty()) {
-        // start new thead
-        workers.unlock();
-        s = new scoped_timer_state;
-        ++num_workers;
-        init_state(ms, eh);
-        s->m_thread = std::thread(thread_func, s);
-    }
-    else {
-        // re-use existing thread
-        s = available_workers.back();
-        available_workers.pop_back();
-        init_state(ms, eh);
-        workers.unlock();
-        s->cv.notify_one();
-    }
-}
-    
-scoped_timer::~scoped_timer() {
-    if (!s)
-        return;
-
-    s->m_mutex.unlock();
-    while (s->work == WORKING)
-        std::this_thread::yield();
-    workers.lock();
-    available_workers.push_back(s);
-    workers.unlock();
 }
 
 void scoped_timer::initialize() {
-#ifndef _WINDOWS
-    static bool pthread_atfork_set = false;
-    if (!pthread_atfork_set) {
-        pthread_atfork(finalize, nullptr, nullptr);
-        pthread_atfork_set = true;
-    }
-#endif
 }
 
 void scoped_timer::finalize() {
-    unsigned deleted = 0;
-    while (deleted < num_workers) {
-        workers.lock();
-        for (auto w : available_workers) {
-            w->work = EXITING;
-            w->cv.notify_one();
-        }
-        decltype(available_workers) cleanup_workers;
-        std::swap(available_workers, cleanup_workers);
-        workers.unlock();
-
-        for (auto w : cleanup_workers) {
-            ++deleted;
-            w->m_thread.join();
-            delete w;
-        }
-    }
-    num_workers = 0;
-    available_workers.clear();
-}
-
-void scoped_timer::init_state(unsigned ms, event_handler * eh) {
-    s->ms = ms;
-    s->eh = eh;
-    s->m_mutex.lock();
-    s->work = WORKING;
 }
diff --git a/src/util/scoped_timer.h b/src/util/scoped_timer.h
index 2f6875d36..d850654c2 100644
--- a/src/util/scoped_timer.h
+++ b/src/util/scoped_timer.h
@@ -20,17 +20,11 @@ Revision History:
 
 #include "util/event_handler.h"
 
-struct scoped_timer_state;
-
 class scoped_timer {
-    scoped_timer_state *s = nullptr;
 public:
     scoped_timer(unsigned ms, event_handler * eh);
-    ~scoped_timer();
     static void initialize();
     static void finalize();
-private:
-    void init_state(unsigned ms, event_handler * eh);
 };
 
 /*
